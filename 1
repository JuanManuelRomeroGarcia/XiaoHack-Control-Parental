class _Win32OverlayWindow:
        def __init__(self, x, y, w, h, subtitle: str, opacity: float):
            self.x, self.y, self.w, self.h = x, y, w, h
            self.subtitle = subtitle
            self.opacity = opacity
            self._text = "60"

            ex = WS_EX_LAYERED | WS_EX_TOPMOST | WS_EX_TOOLWINDOW | WS_EX_NOACTIVATE | WS_EX_TRANSPARENT
            self.hwnd = win32gui.CreateWindowEx(ex, "Static", None, WS_POPUP, x, y, w, h, 0, 0, 0, None)
            _HWND_MAP[int(self.hwnd)] = self

            # Subclase con ctypes para click-through y pintura
            import ctypes as ct
            from ctypes import wintypes as WT
            GWL_WNDPROC = -4  # noqa: F841
            WNDPROC = ct.WINFUNCTYPE(ct.c_long, WT.HWND, ct.c_uint, WT.WPARAM, WT.LPARAM)
            

            def _wndproc(hWnd, msg, wParam, lParam):
                try:
                    if msg == win32con.WM_NCHITTEST:
                        return win32con.HTTRANSPARENT
                    if msg == win32con.WM_PAINT:
                        self._on_paint(hWnd)
                        return 0
                    if msg in (win32con.WM_MOUSEACTIVATE, win32con.WM_ACTIVATE, win32con.WM_SETFOCUS):
                        return 0
                except Exception:
                    pass
                return user32.DefWindowProcW(hWnd, msg, wParam, lParam)

            self._new_wndproc = WNDPROC(_wndproc)  # mantener viva la ref
            user32.SetWindowLongPtrW(self.hwnd, -4, self._new_wndproc)

            # Opacidad global
            user32.SetLayeredWindowAttributes(self.hwnd, 0, int(self.opacity * 255), LWA_ALPHA)

            win32gui.SetWindowPos(self.hwnd, win32con.HWND_TOPMOST, x, y, w, h,
                                  win32con.SWP_NOACTIVATE | win32con.SWP_SHOWWINDOW)
            self.visible = True

        def _on_paint(self, hwnd):
            hdc, ps = win32gui.BeginPaint(hwnd)
            try:
                # Fondo negro (la transparencia la aplica el alpha global del layered)
                brush = win32gui.CreateSolidBrush(win32api.RGB(0, 0, 0))
                win32gui.FillRect(hdc, win32gui.GetClientRect(hwnd), brush)
                win32gui.DeleteObject(brush)

                import math
                rect = win32gui.GetClientRect(hwnd)
                w = rect[2] - rect[0]
                h = rect[3] - rect[1]

                # Tallas: número grande y subtítulo más pequeño
                diag = int(math.hypot(w, h))
                size_main = max(48, min(140, diag // 18))
                size_sub  = max(16, min(36,  diag // 60))

                lf1 = win32gui.LOGFONT()
                lf1.lfFaceName="Segoe UI"
                lf1.lfHeight=-size_main
                lf1.lfWeight=700
                hfont1 = win32gui.CreateFontIndirect(lf1)
                lf2 = win32gui.LOGFONT()
                lf2.lfFaceName="Segoe UI"
                lf2.lfHeight=-size_sub
                lf2.lfWeight=400
                hfont2 = win32gui.CreateFontIndirect(lf2)

                win32gui.SetBkMode(hdc, win32con.TRANSPARENT)

                # 1) Número — en la mitad superior del banner (evita solape)
                rect_num = (rect[0], int(h * 0.03), rect[2], int(h * 0.60))
                win32gui.SetTextColor(hdc, win32api.RGB(255, 255, 255))
                win32gui.SelectObject(hdc, hfont1)
                win32gui.DrawText(hdc, self._text, -1, rect_num,
                                win32con.DT_CENTER | win32con.DT_VCENTER | win32con.DT_SINGLELINE)

                # 2) Subtítulo — parte baja del banner
                rect_sub = (rect[0], int(h * 0.64), rect[2], rect[3])
                win32gui.SetTextColor(hdc, win32api.RGB(220, 220, 220))
                win32gui.SelectObject(hdc, hfont2)
                win32gui.DrawText(hdc, self.subtitle, -1, rect_sub,
                                win32con.DT_CENTER | win32con.DT_TOP)

                win32gui.DeleteObject(hfont1)
                win32gui.DeleteObject(hfont2)
            finally:
                win32gui.EndPaint(hwnd, ps)

        def show(self, text: str):
            self._text = text
            win32gui.InvalidateRect(self.hwnd, None, True)
            if not self.visible:
                win32gui.ShowWindow(self.hwnd, win32con.SW_SHOWNA)
                self.visible = True

        def hide(self):
            if self.visible:
                win32gui.ShowWindow(self.hwnd, win32con.SW_HIDE)
                self.visible = False

        def destroy(self):
            try:
                self.hide()
            except Exception: 
                pass
            try: 
                win32gui.DestroyWindow(self.hwnd)
            except Exception: 
                pass
            _HWND_MAP.pop(int(self.hwnd), None)

    class Win32OverlayManager:
        """
        Crea las ventanas del overlay solo cuando hace falta (lazy) y
        las mantiene SIEMPRE ocultas al iniciar para evitar el flash inicial.
        """
        def __init__(self):
            self.windows: list[_Win32OverlayWindow] = []
            self.subtitle = "Último minuto • Guarda tu partida"
            self.mode, self.position, self.height_px, self.opacity = _overlay_settings()
            self._ready = False           # ← aún no se han creado las ventanas
            self._last_monitors = None    # firma simple para detectar cambios de monitores

        def _monitors_signature(self) -> tuple:
            """Firma simple del layout de monitores para recrear si cambian."""
            try:
                sig = []
                for _hMon, _hdc, (l1, t, r, b) in win32api.EnumDisplayMonitors():
                    sig.append((l1, t, r, b))
                return tuple(sig)
            except Exception:
                # primario
                sw = win32api.GetSystemMetrics(0)
                sh = win32api.GetSystemMetrics(1)
                return ((0, 0, sw, sh),)

        def _init_monitors(self, make_visible: bool = False):
            """
            Crea todas las ventanas. Si make_visible=False, las deja ocultas explícitamente.
            """
            self.windows.clear()
            try:
                mons = win32api.EnumDisplayMonitors()
                for _hMon, _hdc, (l1, t, r, b) in mons:
                    w, h = r - l1, b - t
                    if self.mode == "banner":
                        hh = min(self.height_px, max(80, int(h * 0.22)))
                        y  = t if self.position == "top" else b - hh
                        wnd = _Win32OverlayWindow(l1, y, w, hh, self.subtitle, self.opacity)
                    else:
                        wnd = _Win32OverlayWindow(l1, t, w, h, self.subtitle, self.opacity)
                    self.windows.append(wnd)
            except Exception as e:
                log.warning("EnumDisplayMonitors no disponible (%s), usando primario", e)
                sw = win32api.GetSystemMetrics(0)
                sh = win32api.GetSystemMetrics(1)
                if self.mode == "banner":
                    hh = min(self.height_px, max(80, int(sh * 0.22)))
                    y  = 0 if self.position == "top" else sh - hh
                    self.windows.append(_Win32OverlayWindow(0, y, sw, hh, self.subtitle, self.opacity))
                else:
                    self.windows.append(_Win32OverlayWindow(0, 0, sw, sh, self.subtitle, self.opacity))

            # MUY IMPORTANTE: ocultar todo inmediatamente al crear si no queremos visibilidad inicial
            if not make_visible:
                try:
                    for w in self.windows:
                        w.hide()
                except Exception:
                    pass

            self._ready = True
            self._last_monitors = self._monitors_signature()

        def _ensure_ready(self, make_visible: bool = False):
            """Crea las ventanas si aún no existen o si cambió la geometría de monitores."""
            sig = self._monitors_signature()
            if (not self._ready) or (self._last_monitors != sig):
                # destruir lo anterior si existe
                if self._ready:
                    try:
                        for w in self.windows:
                            w.destroy()
                    except Exception:
                        pass
                    self.windows.clear()
                    self._ready = False
                # crear nuevas (ocultas salvo que se pida lo contrario)
                self._init_monitors(make_visible=make_visible)

        def render(self, n: int):
            """
            Pinta el número 'n'. Si no está listo, crea ventanas en modo OCULTO
            y solo las muestra al hacer show(...). Así evitamos flashes al construir.
            """
            if n <= 0:
                # Si nos llaman con 0 por error, asegúrate de ocultar
                self.hide()
                return

            # Asegura ventanas (ocultas) y muestra ya con el número
            self._ensure_ready(make_visible=False)
            txt = str(n)
            for w in self.windows:
                w.show(txt)   # ← aquí es donde realmente se hace visible
                
        def render_text(self, text: str):
            if not text:
                self.hide()
                return
            self._ensure_ready(make_visible=False)
            for w in self.windows:
                w.show(text)

        def hide(self):
            """Oculta todas las ventanas si existen."""
            if not self._ready:
                return
            try:
                for w in self.windows:
                    w.hide()
            except Exception:
                pass

        def destroy(self):
            """Destruye todas las ventanas y limpia estado."""
            try:
                for w in self.windows:
                    w.destroy()
            except Exception:
                pass
            self.windows.clear()
            self._ready = False
            self._last_monitors = None